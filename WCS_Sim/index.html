<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCS Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #111; color: #ccc; overflow: hidden; height: 100vh; font-size: 12px; }
        .app { display: flex; height: 100vh; }

        /* Panels */
        .panel { width: 220px; background: #1a1a1a; padding: 10px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; border-right: 1px solid #333; }
        .panel.right { border-right: none; border-left: 1px solid #333; width: 200px; }
        .panel.hidden { display: none; }
        .section { background: #222; border-radius: 6px; padding: 10px; }
        .section-title { font-size: 10px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }

        /* Main */
        .main { flex: 1; display: flex; flex-direction: column; }
        .toolbar { background: #1a1a1a; padding: 8px 12px; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #333; }

        /* Buttons */
        button { padding: 5px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; background: #333; color: #ccc; transition: background 0.15s; }
        button:hover { background: #444; }
        button.primary { background: #2563eb; color: #fff; }
        button.primary:hover { background: #3b82f6; }
        button.success { background: #059669; color: #fff; }
        button.success:hover { background: #10b981; }
        button.danger { background: #dc2626; color: #fff; }
        button.danger:hover { background: #ef4444; }
        button.sm { padding: 3px 6px; font-size: 9px; }

        /* Inputs */
        input, select { padding: 5px 6px; border: 1px solid #333; border-radius: 4px; background: #1a1a1a; color: #ccc; font-size: 10px; }
        input:focus, select:focus { outline: none; border-color: #2563eb; }
        input[type="number"] { width: 45px; }

        /* Mode Switch */
        .mode-switch { display: flex; align-items: center; gap: 6px; background: #222; padding: 4px 8px; border-radius: 4px; }
        .mode-switch span { font-size: 10px; font-weight: 600; }
        .mode-switch span.active { color: #10b981; }
        .switch { width: 32px; height: 18px; background: #333; border-radius: 9px; position: relative; cursor: pointer; }
        .switch::after { content: ''; position: absolute; width: 14px; height: 14px; background: #666; border-radius: 50%; top: 2px; left: 2px; transition: 0.2s; }
        .switch.on { background: #059669; }
        .switch.on::after { left: 16px; background: #fff; }

        /* Map */
        .map-container { flex: 1; overflow: hidden; position: relative; background: #0a0a0a; }
        .map-viewport { position: absolute; transform-origin: 0 0; }
        .grid { display: grid; gap: 1px; background: #222; padding: 1px; }

        /* Cells */
        .cell { width: 40px; height: 40px; background: #2a2a2a; display: flex; align-items: center; justify-content: center; cursor: crosshair; position: relative; transition: background 0.1s; }
        .cell:hover { background: #3a3a3a; }
        .cell.selected { box-shadow: inset 0 0 0 2px #2563eb; }
        .cell.block { background: #444; }
        .cell.path { background: #b45309; }
        .cell.charge { background: #047857; }
        .cell-num { font-size: 9px; color: rgba(255,255,255,0.5); position: absolute; top: 2px; left: 3px; }

        /* Selection Box */
        .selection-box { position: absolute; border: 1px solid #2563eb; background: rgba(37, 99, 235, 0.15); pointer-events: none; z-index: 500; }

        /* Cell Types */
        .cell-types { display: flex; gap: 4px; }
        .cell-type { width: 24px; height: 24px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; }
        .cell-type:hover { opacity: 0.8; }
        .cell-type.active { border-color: #fff; }
        .cell-type.normal { background: #2a2a2a; }
        .cell-type.block { background: #444; }
        .cell-type.path { background: #b45309; }
        .cell-type.charge { background: #047857; }

        /* Row */
        .row { display: flex; gap: 5px; align-items: center; }

        /* List Items */
        .list { display: flex; flex-direction: column; gap: 3px; max-height: 100px; overflow-y: auto; }
        .list-item { display: flex; align-items: center; justify-content: space-between; padding: 5px 6px; background: #1a1a1a; border-radius: 4px; cursor: pointer; font-size: 10px; }
        .list-item:hover { background: #252525; }
        .list-item.selected { background: #1e3a5f; }

        /* AGV */
        .agv { position: absolute; width: 32px; height: 32px; background: #2563eb; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: move; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.4); transition: left 0.35s ease, top 0.35s ease; }
        .agv::after { content: ''; width: 12px; height: 12px; background: #fff; border-radius: 50%; }
        .agv::before { content: ''; position: absolute; top: 4px; width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 6px solid #fff; }
        .agv.selected { box-shadow: 0 0 0 2px #fff, 0 2px 8px rgba(0,0,0,0.4); }
        .agv.waiting { animation: pulse-wait 1s infinite; }
        .agv-label { position: absolute; bottom: -14px; font-size: 9px; color: #888; white-space: nowrap; }
        @keyframes pulse-wait { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* Rack */
        .rack { position: absolute; width: 36px; height: 36px; background: rgba(124, 58, 237, 0.4); border: 2px solid rgba(124, 58, 237, 0.8); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: move; z-index: 50; backdrop-filter: blur(1px); }
        .rack::before { content: ''; width: 26px; height: 26px; border: 2px solid rgba(255,255,255,0.3); border-radius: 2px; }
        .rack.selected { box-shadow: 0 0 0 2px #fff; background: rgba(124, 58, 237, 0.5); }
        .rack-label { position: absolute; bottom: -14px; font-size: 9px; color: #888; white-space: nowrap; }

        /* Controls Grid */
        .controls-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 3px; }

        /* IO */
        .io-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .io-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .io-btn { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #444; background: #222; cursor: pointer; transition: all 0.1s; }
        .io-btn:active, .io-btn.active { background: #dc2626; border-color: #ef4444; box-shadow: 0 0 10px #dc2626; }
        .io-lamp { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #444; background: #222; transition: all 0.15s; }
        .io-lamp.on { background: #06b6d4; border-color: #22d3ee; box-shadow: 0 0 12px #06b6d4; }
        .io-lamp.flicker { animation: flicker 0.3s infinite; }
        @keyframes flicker { 0%, 100% { background: #06b6d4; box-shadow: 0 0 12px #06b6d4; } 50% { background: #222; box-shadow: none; } }
        .io-label { font-size: 8px; color: #666; }

        /* Monitor Panel */
        .monitor-panel { width: 320px; background: #1a1a1a; border-left: 1px solid #333; display: flex; flex-direction: column; }
        .monitor-panel.hidden { display: none; }
        .monitor-header { padding: 10px; background: #222; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
        .monitor-header h3 { font-size: 12px; font-weight: 600; color: #888; }
        .monitor-content { flex: 1; overflow-y: auto; padding: 10px; }
        .monitor-agv { margin-bottom: 12px; background: #222; border-radius: 6px; overflow: hidden; }
        .monitor-agv-header { padding: 8px 10px; background: #2a2a2a; display: flex; justify-content: space-between; align-items: center; font-weight: 600; font-size: 11px; }
        .monitor-agv-header .status-badge { padding: 2px 8px; border-radius: 10px; font-size: 9px; font-weight: normal; }
        .monitor-agv-header .status-badge.running { background: #059669; color: #fff; }
        .monitor-agv-header .status-badge.paused { background: #d97706; color: #fff; }
        .monitor-agv-header .status-badge.stopped { background: #444; color: #888; }
        .monitor-task-list { max-height: 200px; overflow-y: auto; }
        .monitor-task { padding: 6px 10px; font-size: 10px; border-bottom: 1px solid #333; display: flex; align-items: center; gap: 8px; }
        .monitor-task:last-child { border-bottom: none; }
        .monitor-task.current { background: #1e3a5f; }
        .monitor-task .num { background: #333; padding: 2px 6px; border-radius: 3px; font-size: 9px; min-width: 20px; text-align: center; }
        .monitor-task .desc { flex: 1; color: #888; }

        /* Task Editor (Right Panel) */
        .task-add select, .task-add input { font-size: 10px; }

        /* Zoom */
        .zoom-indicator { position: absolute; bottom: 8px; left: 8px; background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; font-size: 10px; color: #666; }

        /* Toggle Buttons */
        .panel-toggle { position: absolute; top: 50%; transform: translateY(-50%); background: #333; color: #888; border: none; padding: 15px 3px; cursor: pointer; z-index: 200; font-size: 10px; }
        .panel-toggle:hover { background: #444; color: #ccc; }
        .panel-toggle.left { left: 0; border-radius: 0 4px 4px 0; }
        .panel-toggle.right { right: 0; border-radius: 4px 0 0 4px; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        /* Selection info */
        .selection-info { font-size: 9px; color: #666; padding: 3px 0; }

        /* Global controls */
        .global-controls { display: flex; gap: 4px; margin-bottom: 6px; }
        .global-controls button { flex: 1; font-size: 9px; padding: 4px; }

        /* AGV Tabs */
        .agv-tabs { display: flex; gap: 3px; margin-bottom: 6px; flex-wrap: wrap; }
        .agv-tab { padding: 3px 8px; background: #333; border-radius: 4px; cursor: pointer; font-size: 9px; }
        .agv-tab:hover { background: #444; }
        .agv-tab.active { background: #2563eb; color: #fff; }

        /* Task list in editor */
        .task-list { display: flex; flex-direction: column; gap: 3px; max-height: 120px; overflow-y: auto; }
        .task-item { display: flex; align-items: center; gap: 4px; padding: 4px 6px; background: #1a1a1a; border-radius: 4px; cursor: grab; font-size: 10px; }
        .task-item.current { background: #1e3a5f; border-left: 2px solid #2563eb; }
        .task-num { background: #333; padding: 1px 5px; border-radius: 3px; font-size: 9px; }
        .task-desc { flex: 1; color: #888; font-size: 9px; }

        /* Status */
        .status { text-align: center; padding: 5px; background: #222; border-radius: 4px; font-size: 10px; color: #666; }
        .status.running { background: #064e3b; color: #10b981; }
        .status.paused { background: #713f12; color: #fbbf24; }

        /* Speed control */
        .speed-control { display: flex; align-items: center; gap: 6px; font-size: 10px; }
        .speed-control input[type="range"] { width: 60px; }
    </style>
</head>
<body>
    <div class="app">
        <!-- Left Panel -->
        <div class="panel" id="leftPanel">
            <div class="section">
                <div class="section-title">Grid</div>
                <div class="row">
                    <input type="number" id="gridCols" value="12" min="3" max="50">
                    <span>x</span>
                    <input type="number" id="gridRows" value="10" min="3" max="50">
                    <button onclick="generateGrid()">Apply</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Cell Type</div>
                <div class="row">
                    <div class="cell-types">
                        <div class="cell-type normal active" data-type="normal" onclick="selectCellType('normal')"></div>
                        <div class="cell-type block" data-type="block" onclick="selectCellType('block')"></div>
                        <div class="cell-type path" data-type="path" onclick="selectCellType('path')"></div>
                        <div class="cell-type charge" data-type="charge" onclick="selectCellType('charge')"></div>
                    </div>
                    <input type="number" id="cellNumber" placeholder="#" style="width:40px">
                    <button onclick="assignNumber()">Set</button>
                </div>
                <div class="selection-info" id="selectionInfo">No selection</div>
            </div>

            <div class="section">
                <div class="section-title">AGV</div>
                <div class="list" id="agvList"></div>
                <div class="row" style="margin-top:5px;">
                    <button class="success" onclick="addAGV()" style="flex:1">+ Add</button>
                    <button class="danger" onclick="deleteSelectedAGV()">Del</button>
                </div>
                <div class="controls-grid" style="margin-top:6px;">
                    <button onclick="agvAction('turnLeft')">L</button>
                    <button onclick="agvAction('forward')">Fwd</button>
                    <button onclick="agvAction('turnRight')">R</button>
                    <button onclick="agvAction('liftUp')">Up</button>
                    <button onclick="agvAction('move')">Go</button>
                    <button onclick="agvAction('liftDown')">Dn</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Rack</div>
                <div class="list" id="rackList"></div>
                <div class="row" style="margin-top:5px;">
                    <button class="success" onclick="addRack()" style="flex:1">+ Add</button>
                    <button class="danger" onclick="deleteSelectedRack()">Del</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Data</div>
                <div class="row">
                    <button onclick="exportData()" style="flex:1">Export</button>
                    <button onclick="importData()" style="flex:1">Import</button>
                    <button class="danger" onclick="clearAllData()">Clear</button>
                </div>
                <input type="file" id="importFile" style="display:none" accept=".json" onchange="handleImport(event)">
            </div>
        </div>

        <!-- Main -->
        <div class="main">
            <div class="toolbar">
                <div class="mode-switch">
                    <span id="manualLabel" class="active">MAN</span>
                    <div class="switch" id="modeSwitch" onclick="toggleMode()"></div>
                    <span id="autoLabel">AUTO</span>
                </div>
                <div class="speed-control">
                    <span>Speed:</span>
                    <input type="range" id="speedSlider" min="1" max="5" value="2" onchange="updateSpeed()">
                    <span id="speedLabel">2x</span>
                </div>
                <button onclick="resetView()">Reset</button>
                <button onclick="togglePanel('left')">Settings</button>
                <button onclick="togglePanel('right')">Tasks</button>
                <button onclick="toggleMonitor()">Monitor</button>
            </div>

            <div class="map-container" id="mapContainer">
                <div class="map-viewport" id="mapViewport">
                    <div class="grid" id="grid"></div>
                </div>
                <div class="zoom-indicator" id="zoomIndicator">100%</div>
            </div>

            <button class="panel-toggle left" onclick="togglePanel('left')">&#9666;</button>
            <button class="panel-toggle right" onclick="togglePanel('right')">&#9656;</button>
        </div>

        <!-- Right Panel - Task Editor -->
        <div class="panel right" id="rightPanel">
            <div class="section">
                <div class="section-title">I/O</div>
                <div style="margin-bottom:4px;color:#555;font-size:9px;">Inputs</div>
                <div class="io-grid" id="inputGrid"></div>
                <div style="margin:6px 0 4px;color:#555;font-size:9px;">Outputs</div>
                <div class="io-grid" id="outputGrid"></div>
            </div>

            <div class="section">
                <div class="section-title">Task Editor</div>
                <div class="global-controls">
                    <button class="success" onclick="runAllFlows()">All Run</button>
                    <button onclick="pauseAllFlows()">Pause</button>
                    <button class="danger" onclick="stopAllFlows()">Stop</button>
                </div>

                <div class="agv-tabs" id="agvTabs"></div>
                <div class="task-list" id="taskList"></div>

                <div style="margin-top:6px;">
                    <select id="taskType" onchange="updateTaskParams()" style="width:100%;">
                        <option value="move">Move to Cell</option>
                        <option value="turn">Turn</option>
                        <option value="liftUp">Lift Up</option>
                        <option value="liftDown">Lift Down</option>
                        <option value="carryTo">Carry Rack</option>
                        <option value="wait">Wait</option>
                        <option value="inputWait">Wait Input</option>
                        <option value="outputOn">Output ON</option>
                        <option value="outputFlicker">Output Flicker</option>
                        <option value="outputOff">Output OFF</option>
                    </select>
                    <div class="row" style="margin-top:4px;" id="taskParams"></div>
                    <button class="success" onclick="addTask()" style="width:100%;margin-top:4px;">+ Add</button>
                </div>

                <div class="row" style="margin-top:6px;">
                    <label style="display:flex;align-items:center;gap:4px;font-size:10px;">
                        <input type="checkbox" id="loopFlow"> Loop
                    </label>
                    <button class="success" onclick="runCurrentFlow()" style="flex:1">Run</button>
                    <button class="danger" onclick="stopCurrentFlow()">Stop</button>
                </div>
            </div>
        </div>

        <!-- Monitor Panel -->
        <div class="monitor-panel" id="monitorPanel">
            <div class="monitor-header">
                <h3>Task Monitor</h3>
                <button onclick="toggleMonitor()">X</button>
            </div>
            <div class="monitor-content" id="monitorContent"></div>
        </div>
    </div>

    <script>
        // State
        let gridData = [];
        let selectedCells = new Set();
        let currentCellType = 'normal';
        let agvs = [];
        let racks = [];
        let selectedAGV = null;
        let selectedRack = null;
        let selectedTaskAGV = null;
        let isAutoMode = false;
        let inputs = Array(8).fill(false);
        let outputs = Array(8).fill({ state: 'off' }); // off, on, flicker
        let flickerIntervals = {};
        let agvSpeed = 400; // ms per move

        // Map state
        let zoom = 1;
        let panX = 20, panY = 20;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;

        // Selection state
        let isSelecting = false;
        let selectionStartX = 0, selectionStartY = 0;
        let selectionBox = null;
        let lastClickedCell = null;

        // Dragging
        let draggedItem = null;
        let dragOffset = { x: 0, y: 0 };

        // Init
        document.addEventListener('DOMContentLoaded', () => {
            loadFromStorage();
            initIO();
            updateTaskParams();
            setupMapEvents();
            renderMonitor();
            setInterval(autoSave, 2000);
            setInterval(renderMonitor, 500);
        });

        // LocalStorage
        function autoSave() {
            const data = {
                gridCols: parseInt(document.getElementById('gridCols').value),
                gridRows: parseInt(document.getElementById('gridRows').value),
                gridData,
                agvs: agvs.map(a => ({ ...a, flowState: 'stopped', currentTaskIndex: 0, waiting: false })),
                racks
            };
            localStorage.setItem('wcs_data', JSON.stringify(data));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('wcs_data');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    document.getElementById('gridCols').value = data.gridCols || 12;
                    document.getElementById('gridRows').value = data.gridRows || 10;
                    gridData = data.gridData || [];
                    agvs = (data.agvs || []).map(a => ({ ...a, flowState: 'stopped', currentTaskIndex: 0, waiting: false }));
                    racks = data.racks || [];
                    selectedTaskAGV = agvs[0]?.id || null;
                    if (gridData.length) {
                        renderGrid();
                        renderAGVList();
                        renderRackList();
                        renderAGVTabs();
                        renderTaskList();
                        return;
                    }
                } catch (e) { console.error('Load error:', e); }
            }
            generateGrid();
        }

        function clearAllData() {
            if (!confirm('Clear all data?')) return;
            localStorage.removeItem('wcs_data');
            location.reload();
        }

        // Speed control
        function updateSpeed() {
            const val = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('speedLabel').textContent = val + 'x';
            agvSpeed = 600 - (val * 100); // 1x=500ms, 5x=100ms
        }

        // Grid
        function generateGrid() {
            const cols = parseInt(document.getElementById('gridCols').value) || 12;
            const rows = parseInt(document.getElementById('gridRows').value) || 10;
            gridData = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    gridData.push({ row: r, col: c, type: 'normal', number: null });
                }
            }
            selectedCells.clear();
            renderGrid();
            updateSelectionInfo();
        }

        function renderGrid() {
            const container = document.getElementById('grid');
            const cols = parseInt(document.getElementById('gridCols').value) || 12;
            container.style.gridTemplateColumns = `repeat(${cols}, 40px)`;
            container.innerHTML = gridData.map((cell, i) => {
                const classes = ['cell', cell.type];
                if (selectedCells.has(i)) classes.push('selected');
                return `<div class="${classes.join(' ')}" data-index="${i}">${cell.number !== null ? `<span class="cell-num">${cell.number}</span>` : ''}</div>`;
            }).join('');
            renderAGVs();
            renderRacks();
        }

        // Selection System
        function setupMapEvents() {
            const container = document.getElementById('mapContainer');
            const viewport = document.getElementById('mapViewport');
            const grid = document.getElementById('grid');

            grid.addEventListener('mousedown', (e) => {
                const cell = e.target.closest('.cell');
                if (!cell || e.button !== 0) return;
                e.preventDefault();
                const index = parseInt(cell.dataset.index);
                const rect = viewport.getBoundingClientRect();

                if (e.shiftKey && lastClickedCell !== null) {
                    selectRange(lastClickedCell, index, !e.ctrlKey);
                    updateSelectionInfo();
                    return;
                }

                if (e.ctrlKey) {
                    selectedCells.has(index) ? selectedCells.delete(index) : selectedCells.add(index);
                    lastClickedCell = index;
                    renderGrid();
                    updateSelectionInfo();
                    return;
                }

                isSelecting = true;
                lastClickedCell = index;
                selectionStartX = e.clientX;
                selectionStartY = e.clientY;
                selectedCells.clear();
                selectedCells.add(index);
                renderGrid();

                selectionBox = document.createElement('div');
                selectionBox.className = 'selection-box';
                selectionBox.style.left = (e.clientX - rect.left) + 'px';
                selectionBox.style.top = (e.clientY - rect.top) + 'px';
                viewport.appendChild(selectionBox);
            });

            document.addEventListener('mousemove', (e) => {
                if (isSelecting && selectionBox) {
                    const rect = viewport.getBoundingClientRect();
                    const x1 = Math.min(selectionStartX, e.clientX) - rect.left;
                    const y1 = Math.min(selectionStartY, e.clientY) - rect.top;
                    const x2 = Math.max(selectionStartX, e.clientX) - rect.left;
                    const y2 = Math.max(selectionStartY, e.clientY) - rect.top;
                    selectionBox.style.left = x1 + 'px';
                    selectionBox.style.top = y1 + 'px';
                    selectionBox.style.width = (x2 - x1) + 'px';
                    selectionBox.style.height = (y2 - y1) + 'px';
                    selectCellsInBox(x1 / zoom, y1 / zoom, x2 / zoom, y2 / zoom);
                }

                if (isPanning) {
                    panX = e.clientX - panStartX;
                    panY = e.clientY - panStartY;
                    updateViewport();
                }

                if (draggedItem) {
                    const rect = viewport.getBoundingClientRect();
                    const x = (e.clientX - rect.left - dragOffset.x) / zoom;
                    const y = (e.clientY - rect.top - dragOffset.y) / zoom;
                    const col = Math.floor(x / 41);
                    const row = Math.floor(y / 41);
                    const cols = parseInt(document.getElementById('gridCols').value);
                    const rows = parseInt(document.getElementById('gridRows').value);

                    if (col >= 0 && col < cols && row >= 0 && row < rows) {
                        const cellIndex = row * cols + col;
                        if (gridData[cellIndex] && gridData[cellIndex].type !== 'block') {
                            draggedItem.item.row = row;
                            draggedItem.item.col = col;
                            if (draggedItem.type === 'agv' && draggedItem.item.carriedRack) {
                                const rack = racks.find(r => r.id === draggedItem.item.carriedRack);
                                if (rack) { rack.row = row; rack.col = col; }
                            }
                            draggedItem.type === 'agv' ? renderAGVs() : renderRacks();
                        }
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isSelecting) {
                    isSelecting = false;
                    if (selectionBox) { selectionBox.remove(); selectionBox = null; }
                    updateSelectionInfo();
                }
                if (e.button === 2) { isPanning = false; viewport.style.cursor = 'default'; }
                if (draggedItem) { draggedItem = null; renderAGVList(); renderRackList(); }
            });

            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX - panX;
                    panStartY = e.clientY - panY;
                    viewport.style.cursor = 'grabbing';
                }
            });

            container.addEventListener('contextmenu', (e) => e.preventDefault());
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom = Math.max(0.3, Math.min(2, zoom + (e.deltaY > 0 ? -0.1 : 0.1)));
                updateViewport();
            });
        }

        function selectCellsInBox(x1, y1, x2, y2) {
            const cols = parseInt(document.getElementById('gridCols').value);
            const cellSize = 41;
            selectedCells.clear();
            for (let r = Math.floor(y1 / cellSize); r <= Math.floor(y2 / cellSize); r++) {
                for (let c = Math.floor(x1 / cellSize); c <= Math.floor(x2 / cellSize); c++) {
                    const index = r * cols + c;
                    if (index >= 0 && index < gridData.length) selectedCells.add(index);
                }
            }
            renderGrid();
        }

        function selectRange(fromIndex, toIndex, clearPrevious = true) {
            const cols = parseInt(document.getElementById('gridCols').value);
            const [fromRow, fromCol] = [Math.floor(fromIndex / cols), fromIndex % cols];
            const [toRow, toCol] = [Math.floor(toIndex / cols), toIndex % cols];
            if (clearPrevious) selectedCells.clear();
            for (let r = Math.min(fromRow, toRow); r <= Math.max(fromRow, toRow); r++) {
                for (let c = Math.min(fromCol, toCol); c <= Math.max(fromCol, toCol); c++) {
                    selectedCells.add(r * cols + c);
                }
            }
            renderGrid();
        }

        function clearSelection() { selectedCells.clear(); lastClickedCell = null; renderGrid(); updateSelectionInfo(); }

        function updateSelectionInfo() {
            const info = document.getElementById('selectionInfo');
            const count = selectedCells.size;
            if (count === 0) info.textContent = 'No selection';
            else if (count === 1) {
                const idx = Array.from(selectedCells)[0];
                const cols = parseInt(document.getElementById('gridCols').value);
                info.textContent = `Cell (${Math.floor(idx / cols)}, ${idx % cols})`;
            } else info.textContent = `${count} cells`;
        }

        function updateViewport() {
            document.getElementById('mapViewport').style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            document.getElementById('zoomIndicator').textContent = `${Math.round(zoom * 100)}%`;
        }

        function resetView() { zoom = 1; panX = 20; panY = 20; updateViewport(); }

        // Cell Types
        function selectCellType(type) {
            currentCellType = type;
            document.querySelectorAll('.cell-type').forEach(el => el.classList.toggle('active', el.dataset.type === type));
            if (selectedCells.size > 0) {
                selectedCells.forEach(i => { gridData[i].type = type; });
                renderGrid();
            }
        }

        function assignNumber() {
            const num = parseInt(document.getElementById('cellNumber').value);
            if (!isNaN(num) && selectedCells.size > 0) {
                Array.from(selectedCells).sort((a, b) => a - b).forEach((idx, i) => { gridData[idx].number = num + i; });
                renderGrid();
            }
        }

        // AGV
        function addAGV() {
            if (agvs.length >= 6) return alert('Max 6 AGVs');
            const id = Date.now();
            agvs.push({
                id, name: `AGV${agvs.length + 1}`, row: 0, col: agvs.length,
                direction: 0, isLifted: false, carriedRack: null,
                tasks: [], flowState: 'stopped', currentTaskIndex: 0, loop: false, waiting: false
            });
            renderAGVList();
            renderAGVs();
            renderAGVTabs();
            selectTaskAGV(id);
            updateTaskParams();
            renderMonitor();
        }

        function renderAGVList() {
            document.getElementById('agvList').innerHTML = agvs.map(a =>
                `<div class="list-item ${selectedAGV === a.id ? 'selected' : ''}" onclick="selectAGV(${a.id})">${a.name}</div>`
            ).join('');
        }

        function selectAGV(id) {
            selectedAGV = selectedAGV === id ? null : id;
            selectedRack = null;
            renderAGVList(); renderRackList(); renderAGVs();
        }

        function deleteSelectedAGV() {
            if (!selectedAGV) return;
            agvs = agvs.filter(a => a.id !== selectedAGV);
            if (selectedTaskAGV === selectedAGV) selectedTaskAGV = agvs[0]?.id || null;
            selectedAGV = null;
            renderAGVList(); renderAGVs(); renderAGVTabs(); renderTaskList(); renderMonitor();
        }

        function renderAGVs() {
            document.querySelectorAll('.agv').forEach(el => el.remove());
            const viewport = document.getElementById('mapViewport');
            agvs.forEach(agv => {
                const el = document.createElement('div');
                el.className = `agv ${selectedAGV === agv.id ? 'selected' : ''} ${agv.waiting ? 'waiting' : ''}`;
                el.style.left = `${agv.col * 41 + 5}px`;
                el.style.top = `${agv.row * 41 + 5}px`;
                el.style.transform = `rotate(${agv.direction}deg)`;
                el.innerHTML = `<span class="agv-label">${agv.name}</span>`;
                el.addEventListener('mousedown', (e) => { if (!isAutoMode) startDrag(e, 'agv', agv); });
                el.addEventListener('click', (e) => { e.stopPropagation(); selectAGV(agv.id); });
                viewport.appendChild(el);
            });
        }

        // Rack
        function addRack() {
            if (racks.length >= 6) return alert('Max 6 Racks');
            racks.push({ id: Date.now(), name: `R${racks.length + 1}`, row: 1, col: racks.length, carried: false });
            renderRackList(); renderRacks(); updateTaskParams();
        }

        function renderRackList() {
            document.getElementById('rackList').innerHTML = racks.map(r =>
                `<div class="list-item ${selectedRack === r.id ? 'selected' : ''}" onclick="selectRack(${r.id})">${r.name}</div>`
            ).join('');
        }

        function selectRack(id) {
            selectedRack = selectedRack === id ? null : id;
            selectedAGV = null;
            renderAGVList(); renderRackList(); renderRacks();
        }

        function deleteSelectedRack() {
            if (!selectedRack) return;
            const rack = racks.find(r => r.id === selectedRack);
            if (rack?.carried) {
                const agv = agvs.find(a => a.carriedRack === selectedRack);
                if (agv) agv.carriedRack = null;
            }
            racks = racks.filter(r => r.id !== selectedRack);
            selectedRack = null;
            renderRackList(); renderRacks(); updateTaskParams();
        }

        function renderRacks() {
            document.querySelectorAll('.rack').forEach(el => el.remove());
            const viewport = document.getElementById('mapViewport');
            racks.filter(r => !r.carried).forEach(rack => {
                const el = document.createElement('div');
                el.className = `rack ${selectedRack === rack.id ? 'selected' : ''}`;
                el.style.left = `${rack.col * 41 + 3}px`;
                el.style.top = `${rack.row * 41 + 3}px`;
                el.innerHTML = `<span class="rack-label">${rack.name}</span>`;
                el.addEventListener('mousedown', (e) => { if (!isAutoMode && !rack.carried) startDrag(e, 'rack', rack); });
                el.addEventListener('click', (e) => { e.stopPropagation(); selectRack(rack.id); });
                viewport.appendChild(el);
            });
        }

        function startDrag(e, type, item) {
            e.preventDefault(); e.stopPropagation();
            draggedItem = { type, item };
            const rect = e.target.getBoundingClientRect();
            dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        // AGV Actions (Manual)
        function agvAction(action) {
            if (isAutoMode) return alert('Switch to Manual mode');
            if (!selectedAGV) return alert('Select an AGV');
            const agv = agvs.find(a => a.id === selectedAGV);
            if (!agv) return;

            switch(action) {
                case 'forward': moveAGVForward(agv); break;
                case 'turnLeft': agv.direction = (agv.direction - 90 + 360) % 360; break;
                case 'turnRight': agv.direction = (agv.direction + 90) % 360; break;
                case 'liftUp':
                    agv.isLifted = true;
                    const rackAtPos = racks.find(r => r.row === agv.row && r.col === agv.col && !r.carried);
                    if (rackAtPos) { rackAtPos.carried = true; agv.carriedRack = rackAtPos.id; }
                    break;
                case 'liftDown':
                    agv.isLifted = false;
                    if (agv.carriedRack) {
                        const rack = racks.find(r => r.id === agv.carriedRack);
                        if (rack) { rack.carried = false; rack.row = agv.row; rack.col = agv.col; }
                        agv.carriedRack = null;
                    }
                    break;
                case 'move':
                    if (selectedCells.size === 1) {
                        const idx = Array.from(selectedCells)[0];
                        moveAGVToCell(agv, gridData[idx].row, gridData[idx].col);
                    } else alert('Select one cell');
                    break;
            }
            renderAGVs(); renderRacks();
        }

        function moveAGVForward(agv) {
            const cols = parseInt(document.getElementById('gridCols').value);
            const rows = parseInt(document.getElementById('gridRows').value);
            let [newRow, newCol] = [agv.row, agv.col];
            switch(agv.direction) {
                case 0: newRow--; break;
                case 90: newCol++; break;
                case 180: newRow++; break;
                case 270: newCol--; break;
            }
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                const idx = newRow * cols + newCol;
                if (gridData[idx].type !== 'block' && !isCellOccupiedByOtherAGV(agv.id, newRow, newCol)) {
                    agv.row = newRow; agv.col = newCol;
                    if (agv.carriedRack) {
                        const rack = racks.find(r => r.id === agv.carriedRack);
                        if (rack) { rack.row = newRow; rack.col = newCol; }
                    }
                }
            }
        }

        // Collision Detection
        function isCellOccupiedByOtherAGV(currentAgvId, row, col) {
            return agvs.some(a => a.id !== currentAgvId && a.row === row && a.col === col);
        }

        function isPathBlocked(agv, nextRow, nextCol) {
            const cols = parseInt(document.getElementById('gridCols').value);
            const idx = nextRow * cols + nextCol;
            if (!gridData[idx] || gridData[idx].type === 'block') return true;
            if (isCellOccupiedByOtherAGV(agv.id, nextRow, nextCol)) return true;
            return false;
        }

        async function moveAGVToCell(agv, targetRow, targetCol) {
            const cols = parseInt(document.getElementById('gridCols').value);

            while (agv.row !== targetRow || agv.col !== targetCol) {
                if (agv.flowState === 'stopped') break;
                while (agv.flowState === 'paused') { await sleep(100); if (agv.flowState === 'stopped') return; }

                let nextRow = agv.row, nextCol = agv.col;
                if (agv.row < targetRow) nextRow++;
                else if (agv.row > targetRow) nextRow--;
                else if (agv.col < targetCol) nextCol++;
                else if (agv.col > targetCol) nextCol--;

                if (isPathBlocked(agv, nextRow, nextCol)) {
                    agv.waiting = true;
                    renderAGVs();
                    await sleep(300);
                    continue;
                }

                agv.waiting = false;

                if (nextRow < agv.row) agv.direction = 0;
                else if (nextRow > agv.row) agv.direction = 180;
                else if (nextCol > agv.col) agv.direction = 90;
                else if (nextCol < agv.col) agv.direction = 270;

                agv.row = nextRow; agv.col = nextCol;
                if (agv.carriedRack) {
                    const rack = racks.find(r => r.id === agv.carriedRack);
                    if (rack) { rack.row = nextRow; rack.col = nextCol; }
                }
                renderAGVs(); renderRacks();
                await sleep(agvSpeed);
            }
            agv.waiting = false;
            renderAGVList();
        }

        // IO
        function initIO() {
            outputs = Array(8).fill(null).map(() => ({ state: 'off' }));
            document.getElementById('inputGrid').innerHTML = Array(8).fill(0).map((_, i) =>
                `<div class="io-item"><button class="io-btn" onmousedown="setInput(${i},true)" onmouseup="setInput(${i},false)" onmouseleave="setInput(${i},false)"></button><span class="io-label">I${i+1}</span></div>`
            ).join('');
            document.getElementById('outputGrid').innerHTML = Array(8).fill(0).map((_, i) =>
                `<div class="io-item"><div class="io-lamp" id="out${i}"></div><span class="io-label">O${i+1}</span></div>`
            ).join('');
        }

        function setInput(i, state) { inputs[i] = state; document.querySelectorAll('.io-btn')[i].classList.toggle('active', state); }

        function setOutput(i, state) {
            // Clear any existing flicker
            if (flickerIntervals[i]) {
                clearInterval(flickerIntervals[i]);
                delete flickerIntervals[i];
            }

            const lamp = document.getElementById(`out${i}`);
            lamp.classList.remove('on', 'flicker');

            if (state === 'on') {
                outputs[i].state = 'on';
                lamp.classList.add('on');
            } else if (state === 'flicker') {
                outputs[i].state = 'flicker';
                lamp.classList.add('on', 'flicker');
            } else {
                outputs[i].state = 'off';
            }
        }

        // Mode
        function toggleMode() {
            isAutoMode = !isAutoMode;
            document.getElementById('modeSwitch').classList.toggle('on', isAutoMode);
            document.getElementById('manualLabel').classList.toggle('active', !isAutoMode);
            document.getElementById('autoLabel').classList.toggle('active', isAutoMode);
            if (!isAutoMode) stopAllFlows();
        }

        function togglePanel(side) {
            document.getElementById(side === 'left' ? 'leftPanel' : 'rightPanel').classList.toggle('hidden');
        }

        function toggleMonitor() {
            document.getElementById('monitorPanel').classList.toggle('hidden');
        }

        // Monitor Panel
        function renderMonitor() {
            const content = document.getElementById('monitorContent');
            content.innerHTML = agvs.map(agv => `
                <div class="monitor-agv">
                    <div class="monitor-agv-header">
                        <span>${agv.name}</span>
                        <span class="status-badge ${agv.flowState}">${agv.flowState}</span>
                    </div>
                    <div class="monitor-task-list">
                        ${agv.tasks.length ? agv.tasks.map((t, i) => `
                            <div class="monitor-task ${agv.flowState === 'running' && agv.currentTaskIndex === i ? 'current' : ''}">
                                <span class="num">${i + 1}</span>
                                <span class="desc">${t.desc}</span>
                            </div>
                        `).join('') : '<div class="monitor-task"><span class="desc" style="color:#555;">No tasks</span></div>'}
                    </div>
                </div>
            `).join('') || '<div style="color:#555;text-align:center;padding:20px;">No AGVs</div>';
        }

        // AGV Task Tabs
        function renderAGVTabs() {
            document.getElementById('agvTabs').innerHTML = agvs.map(a =>
                `<div class="agv-tab ${selectedTaskAGV === a.id ? 'active' : ''}" onclick="selectTaskAGV(${a.id})">${a.name}</div>`
            ).join('');
        }

        function selectTaskAGV(id) {
            selectedTaskAGV = id;
            const agv = agvs.find(a => a.id === id);
            if (agv) document.getElementById('loopFlow').checked = agv.loop;
            renderAGVTabs();
            renderTaskList();
        }

        // Task Flow
        function updateTaskParams() {
            const type = document.getElementById('taskType').value;
            let html = '';
            switch(type) {
                case 'move':
                    html = `<input type="number" id="taskCell" placeholder="Cell #" style="flex:1">`;
                    break;
                case 'carryTo':
                    html = `<select id="taskRack">${racks.map(r => `<option value="${r.id}">${r.name}</option>`).join('')}</select><input type="number" id="taskCell" placeholder="#" style="flex:1">`;
                    break;
                case 'turn':
                    html = `<select id="taskDir" style="flex:1"><option value="left">Left</option><option value="right">Right</option></select>`;
                    break;
                case 'liftUp': case 'liftDown':
                    html = `<span style="color:#555;font-size:9px;">No params</span>`;
                    break;
                case 'wait':
                    html = `<input type="number" id="taskDur" placeholder="Sec" style="flex:1">`;
                    break;
                case 'inputWait':
                    html = `<select id="taskIn" style="flex:1">${Array(8).fill(0).map((_, i) => `<option value="${i}">I${i+1}</option>`).join('')}</select>`;
                    break;
                case 'outputOn': case 'outputFlicker': case 'outputOff':
                    html = `<select id="taskOut" style="flex:1">${Array(8).fill(0).map((_, i) => `<option value="${i}">O${i+1}</option>`).join('')}</select>`;
                    break;
            }
            document.getElementById('taskParams').innerHTML = html;
        }

        function addTask() {
            if (!selectedTaskAGV) return alert('Add AGV first');
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (!agv) return;

            const type = document.getElementById('taskType').value;
            let desc = '', data = { type };

            switch(type) {
                case 'move':
                    const moveCellEl = document.getElementById('taskCell');
                    if (!moveCellEl || !moveCellEl.value) return alert('Enter cell #');
                    data.cellNum = parseInt(moveCellEl.value);
                    desc = `Move -> #${data.cellNum}`;
                    break;
                case 'carryTo':
                    const rackEl = document.getElementById('taskRack');
                    const carryCellEl = document.getElementById('taskCell');
                    if (!rackEl || !rackEl.value) return alert('Add rack first');
                    if (!carryCellEl || !carryCellEl.value) return alert('Enter cell #');
                    data.rackId = parseInt(rackEl.value);
                    data.cellNum = parseInt(carryCellEl.value);
                    desc = `Carry ${racks.find(r => r.id === data.rackId)?.name} -> #${data.cellNum}`;
                    break;
                case 'turn':
                    data.direction = document.getElementById('taskDir')?.value || 'left';
                    desc = `Turn ${data.direction}`;
                    break;
                case 'liftUp': desc = 'Lift up'; break;
                case 'liftDown': desc = 'Lift down'; break;
                case 'wait':
                    const durEl = document.getElementById('taskDur');
                    if (!durEl || !durEl.value) return alert('Enter duration');
                    data.duration = parseInt(durEl.value);
                    desc = `Wait ${data.duration}s`;
                    break;
                case 'inputWait':
                    data.inputIndex = parseInt(document.getElementById('taskIn')?.value || '0');
                    desc = `Wait I${data.inputIndex + 1}`;
                    break;
                case 'outputOn':
                    data.outputIndex = parseInt(document.getElementById('taskOut')?.value || '0');
                    desc = `O${data.outputIndex + 1} ON`;
                    break;
                case 'outputFlicker':
                    data.outputIndex = parseInt(document.getElementById('taskOut')?.value || '0');
                    desc = `O${data.outputIndex + 1} Flicker`;
                    break;
                case 'outputOff':
                    data.outputIndex = parseInt(document.getElementById('taskOut')?.value || '0');
                    desc = `O${data.outputIndex + 1} OFF`;
                    break;
            }

            agv.tasks.push({ ...data, desc });
            renderTaskList();
            renderMonitor();
        }

        function renderTaskList() {
            if (!selectedTaskAGV) {
                document.getElementById('taskList').innerHTML = '<div style="color:#555;text-align:center;padding:10px;font-size:9px;">Add AGV first</div>';
                return;
            }
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (!agv) return;

            document.getElementById('taskList').innerHTML = agv.tasks.map((t, i) =>
                `<div class="task-item ${agv.currentTaskIndex === i && agv.flowState === 'running' ? 'current' : ''}"
                    draggable="true" ondragstart="dragTask(event,${i})" ondragover="event.preventDefault()" ondrop="dropTask(event,${i})">
                    <span class="task-num">${i+1}</span>
                    <span class="task-desc">${t.desc}</span>
                    <button class="sm danger" onclick="deleteTask(${i})">X</button>
                </div>`
            ).join('') || '<div style="color:#555;text-align:center;padding:8px;font-size:9px;">No tasks</div>';
        }

        let draggedTaskIdx = null;
        function dragTask(e, i) { draggedTaskIdx = i; }
        function dropTask(e, i) {
            if (!selectedTaskAGV || draggedTaskIdx === null) return;
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (agv && draggedTaskIdx !== i) {
                const t = agv.tasks.splice(draggedTaskIdx, 1)[0];
                agv.tasks.splice(i, 0, t);
                renderTaskList();
                renderMonitor();
            }
            draggedTaskIdx = null;
        }

        function deleteTask(i) {
            if (!selectedTaskAGV) return;
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (agv) { agv.tasks.splice(i, 1); renderTaskList(); renderMonitor(); }
        }

        // Flow Control
        async function runAGVFlow(agv) {
            if (agv.flowState === 'running') return;
            agv.flowState = 'running';
            agv.loop = document.getElementById('loopFlow').checked;
            renderAGVTabs();
            renderMonitor();

            do {
                for (agv.currentTaskIndex = 0; agv.currentTaskIndex < agv.tasks.length; agv.currentTaskIndex++) {
                    if (agv.flowState === 'stopped') { agv.currentTaskIndex = 0; renderAGVTabs(); renderMonitor(); return; }
                    while (agv.flowState === 'paused') { await sleep(100); if (agv.flowState === 'stopped') return; }
                    renderTaskList();
                    renderMonitor();
                    await executeTask(agv, agv.tasks[agv.currentTaskIndex]);
                }
            } while (agv.loop && agv.flowState === 'running');

            agv.flowState = 'stopped';
            agv.currentTaskIndex = 0;
            renderAGVTabs();
            renderTaskList();
            renderMonitor();
        }

        function runCurrentFlow() {
            if (!isAutoMode) return alert('Switch to Auto');
            if (!selectedTaskAGV) return alert('Select AGV');
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (agv && agv.tasks.length) runAGVFlow(agv);
            else alert('No tasks');
        }

        function stopCurrentFlow() {
            if (!selectedTaskAGV) return;
            const agv = agvs.find(a => a.id === selectedTaskAGV);
            if (agv) {
                agv.flowState = 'stopped';
                agv.currentTaskIndex = 0;
                renderAGVTabs();
                renderTaskList();
                renderMonitor();
            }
        }

        function runAllFlows() {
            if (!isAutoMode) return alert('Switch to Auto');
            agvs.forEach(agv => { if (agv.tasks.length) runAGVFlow(agv); });
        }

        function pauseAllFlows() {
            agvs.forEach(agv => {
                if (agv.flowState === 'running') agv.flowState = 'paused';
                else if (agv.flowState === 'paused') agv.flowState = 'running';
            });
            renderAGVTabs();
            renderMonitor();
        }

        function stopAllFlows() {
            agvs.forEach(agv => { agv.flowState = 'stopped'; agv.currentTaskIndex = 0; });
            renderAGVTabs();
            renderTaskList();
            renderMonitor();
        }

        async function executeTask(agv, task) {
            switch(task.type) {
                case 'move':
                    const moveCell = gridData.find(c => c.number === task.cellNum);
                    if (moveCell) await moveAGVToCell(agv, moveCell.row, moveCell.col);
                    break;
                case 'carryTo':
                    const rack = racks.find(r => r.id === task.rackId);
                    const cell = gridData.find(c => c.number === task.cellNum);
                    if (rack && cell) {
                        if (agv.row !== rack.row || agv.col !== rack.col) await moveAGVToCell(agv, rack.row, rack.col);
                        if (!rack.carried) {
                            rack.carried = true; agv.carriedRack = rack.id; agv.isLifted = true;
                            renderAGVs(); renderRacks(); await sleep(300);
                        }
                        await moveAGVToCell(agv, cell.row, cell.col);
                        rack.carried = false; rack.row = agv.row; rack.col = agv.col;
                        agv.carriedRack = null; agv.isLifted = false;
                        renderAGVs(); renderRacks();
                    }
                    break;
                case 'turn':
                    agv.direction = (agv.direction + (task.direction === 'left' ? -90 : 90) + 360) % 360;
                    renderAGVs();
                    break;
                case 'liftUp':
                    agv.isLifted = true;
                    const rackUp = racks.find(r => r.row === agv.row && r.col === agv.col && !r.carried);
                    if (rackUp) { rackUp.carried = true; agv.carriedRack = rackUp.id; }
                    renderAGVs(); renderRacks();
                    break;
                case 'liftDown':
                    agv.isLifted = false;
                    if (agv.carriedRack) {
                        const rackDown = racks.find(r => r.id === agv.carriedRack);
                        if (rackDown) { rackDown.carried = false; rackDown.row = agv.row; rackDown.col = agv.col; }
                        agv.carriedRack = null;
                    }
                    renderAGVs(); renderRacks();
                    break;
                case 'wait':
                    let waited = 0;
                    while (waited < task.duration * 1000 && agv.flowState === 'running') {
                        await sleep(100);
                        waited += 100;
                    }
                    break;
                case 'inputWait':
                    while (!inputs[task.inputIndex] && agv.flowState === 'running') await sleep(100);
                    break;
                case 'outputOn':
                    setOutput(task.outputIndex, 'on');
                    break;
                case 'outputFlicker':
                    setOutput(task.outputIndex, 'flicker');
                    break;
                case 'outputOff':
                    setOutput(task.outputIndex, 'off');
                    break;
            }
            await sleep(150);
        }

        // Import/Export
        function exportData() {
            const data = {
                gridCols: parseInt(document.getElementById('gridCols').value),
                gridRows: parseInt(document.getElementById('gridRows').value),
                gridData,
                agvs: agvs.map(a => ({ ...a, flowState: 'stopped', currentTaskIndex: 0, waiting: false })),
                racks
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'wcs_data.json';
            a.click();
        }

        function importData() { document.getElementById('importFile').click(); }

        function handleImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    document.getElementById('gridCols').value = data.gridCols;
                    document.getElementById('gridRows').value = data.gridRows;
                    gridData = data.gridData;
                    agvs = (data.agvs || []).map(a => ({ ...a, flowState: 'stopped', currentTaskIndex: 0, waiting: false }));
                    racks = data.racks || [];
                    selectedCells.clear();
                    selectedTaskAGV = agvs[0]?.id || null;
                    renderGrid(); renderAGVList(); renderRackList(); renderAGVTabs(); renderTaskList();
                    updateTaskParams(); resetView(); renderMonitor();
                } catch (err) { alert('Import error: ' + err.message); }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        resetView();
    </script>
</body>
</html>
